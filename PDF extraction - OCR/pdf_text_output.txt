Collecting a Heap of Shapes
Earl T. Barr! Christian Bird? Mark Marron?
'UC Davis ?Microsoft Research 7IMDEA Software Research
Abstract. A large gap exists between the wide range of admissible heap structures
and those that programmers actually build. To understand this gap, we empirically
study heap structures and their sharing relations in real-world programs. Our goal
is to characterize these heaps. Our study rests on a heap abstraction that uses
structural indistinguishability principles to group objects that play the same role.
Our results shed light on prevalence of recursive data-structures, aggregation, and
the sharing patterns that occur in programs. We find, for example, that real-world
heaps are dominated by atomic shapes (79% on average) and the majority of
sharing occurs via common programming idioms. In short, the heap is, in practice,
a simple structure constructed out of a small number of simple structures. Our
findings imply that garbage collection and program analysis may achieve a high
return by focusing on simple heap structures.
1 Introduction
The program heap is fundamentally a simple mathematical concept — a set of objects and
a connectivity relation on them. This clean formalism lends itself well to the application
of powerful deductive mathematical analyses. However, the formalisms — objects,
pointers, types, and fields — that define the program heap in modern object-oriented
languages such as Java or C# are fundamentally under-constrained; a large gap exists
between the range of heap structures that are admissible under the weak constraints
imposed by the type system and the possibly much more limited set of structures
that programmers build in practice. We seek to fill in this gap and understand more
precisely the heap structures in real world programs. We approach these questions via a
naturalistic empirical analysis of real-world heaps. The results of this analysis indicate
that, in practice, the heap is a fundamentally simple structure that is constructed in large
part out of a small number of simple structures and sharing idioms.
This result has substantial implications for programming language research, particu-
larly type and annotation systems [5, 6, 9, 17, 28] and the design of static heap analysis
techniques [7, 26, 27, 29]. Work in these areas generally considers the heap to be an
adversarial setting where the analysis or specification system must effectively handle
a wide range of complex heap structures that could appear. Our results imply that this
pessimistic view does not reflect the reality of how object-oriented programs organize
the heap and may artificially limit the scalability and utility of analysis or annotation
systems built under this assumption.
A major consideration when studying heap structures is to decide the level of abstrac-
tion to employ. A natural idea is to look at how individual objects are related and perhaps
shared [10, 15, 17]. We hypothesize that developers actually think primarily in terms
of the roles that objects play in a program and the relations between these roles rather
than thinking in terms of individual objects. Further, we hypothesize that these relations
are encoded in where pointers to the objects that play each role are stored, i.e. objects
that play the same roles are stored in the same containers or structures while objects
that play different roles are segregated. This allows us to study the heap structures,
and relations between them, at a higher level of abstraction that is closer to what the
developer envisions.
In this paper, we examine the heaps of real-world programs from the DaCapo
suite [4] and find with a high degree of statistical confidence that for object-oriented
programs: unique referencing (a sub-relation of ownership [6]) is an important but not
dominant organization concept (mean of 43% + 12% of types), that aggregation is
the dominant form of composition (mean of 79% + 21% of types), and that all types
sharing can be well organized by a small set of developer-centric concepts (mean of
89% + 6% of types can be precisely categorized). We obtain similar results for the
structures that are built. These results provide information about the relative importance
of set vs. inductive reasoning (aggregate vs. recursive structures) for developing shape
analysis techniques [7, 29], and what structural properties occur frequently in real-world
code [18] (i.e. they must be represented accurately in order to achieve precise results).
The results also imply that, while ownership [5, 6, 17] is important to the design of
object-oriented programs, the strict ownership discipline is often violated. We quantify
these violations and how complex the resulting aliasing relations are [20]. We show that
the majority of sharing that actually occurs can be categorized using a small number
of programming idioms. These results provide possible directions for work on heap
annotation and type systems.
This paper makes the following contributions:
 
 
 
— We use runtime sampling to produce a range of statistically meaningful measure-
ments of the heaps produced by the DaCapo [4] benchmark, a well-known bench-
mark that encompasses a real-world object-oriented programs, selected to represent
a range of application domains and programming idioms;
— We provide evidence that components , as described in [18, 21], usefully and closely
correspond to the roles that developer assign to objects; and
— We identify a small number of idiomatic sharing patterns that describe the majority
of sharing that occurs in practice.
These results confirm some commonly held beliefs about the heap — programmers
avoid sharing and builtin containers are preferred to custom implementations — and pro-
vide actionable information — strict ownership is not the dominant form of organization
and sharing generally occurs in a small number of idiomatic ways — for rethinking the
designs of annotation systems and program analyses.
Section 2 presents the theory that informs that the research questions we address in
this study. Section 3 introduces the formalism upon which our heap analysis tool depends
and defines the measures we use to answer our research questions. Section 4 describes
how we process concrete heaps and compute the data that we analyze. Section 5 presents
the results of our study and answers our research questions. Finally, we examine previous
work on empirical heap studies in Section 6 and summarize our results in Section 7.

